// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: kvstore.proto

#include "kvstore.pb.h"
#include "kvstore.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace kvstore {

static const char* ABDService_method_names[] = {
  "/kvstore.ABDService/Read",
  "/kvstore.ABDService/Write",
};

std::unique_ptr< ABDService::Stub> ABDService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< ABDService::Stub> stub(new ABDService::Stub(channel, options));
  return stub;
}

ABDService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Read_(ABDService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Write_(ABDService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status ABDService::Stub::Read(::grpc::ClientContext* context, const ::kvstore::ABDReadRequest& request, ::kvstore::ABDReadResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::kvstore::ABDReadRequest, ::kvstore::ABDReadResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Read_, context, request, response);
}

void ABDService::Stub::async::Read(::grpc::ClientContext* context, const ::kvstore::ABDReadRequest* request, ::kvstore::ABDReadResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::kvstore::ABDReadRequest, ::kvstore::ABDReadResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, std::move(f));
}

void ABDService::Stub::async::Read(::grpc::ClientContext* context, const ::kvstore::ABDReadRequest* request, ::kvstore::ABDReadResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::kvstore::ABDReadResponse>* ABDService::Stub::PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::kvstore::ABDReadRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::kvstore::ABDReadResponse, ::kvstore::ABDReadRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Read_, context, request);
}

::grpc::ClientAsyncResponseReader< ::kvstore::ABDReadResponse>* ABDService::Stub::AsyncReadRaw(::grpc::ClientContext* context, const ::kvstore::ABDReadRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncReadRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ABDService::Stub::Write(::grpc::ClientContext* context, const ::kvstore::ABDWriteRequest& request, ::kvstore::ABDWriteResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::kvstore::ABDWriteRequest, ::kvstore::ABDWriteResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Write_, context, request, response);
}

void ABDService::Stub::async::Write(::grpc::ClientContext* context, const ::kvstore::ABDWriteRequest* request, ::kvstore::ABDWriteResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::kvstore::ABDWriteRequest, ::kvstore::ABDWriteResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Write_, context, request, response, std::move(f));
}

void ABDService::Stub::async::Write(::grpc::ClientContext* context, const ::kvstore::ABDWriteRequest* request, ::kvstore::ABDWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Write_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::kvstore::ABDWriteResponse>* ABDService::Stub::PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::kvstore::ABDWriteRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::kvstore::ABDWriteResponse, ::kvstore::ABDWriteRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Write_, context, request);
}

::grpc::ClientAsyncResponseReader< ::kvstore::ABDWriteResponse>* ABDService::Stub::AsyncWriteRaw(::grpc::ClientContext* context, const ::kvstore::ABDWriteRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncWriteRaw(context, request, cq);
  result->StartCall();
  return result;
}

ABDService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ABDService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ABDService::Service, ::kvstore::ABDReadRequest, ::kvstore::ABDReadResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ABDService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::kvstore::ABDReadRequest* req,
             ::kvstore::ABDReadResponse* resp) {
               return service->Read(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ABDService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ABDService::Service, ::kvstore::ABDWriteRequest, ::kvstore::ABDWriteResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ABDService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::kvstore::ABDWriteRequest* req,
             ::kvstore::ABDWriteResponse* resp) {
               return service->Write(ctx, req, resp);
             }, this)));
}

ABDService::Service::~Service() {
}

::grpc::Status ABDService::Service::Read(::grpc::ServerContext* context, const ::kvstore::ABDReadRequest* request, ::kvstore::ABDReadResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ABDService::Service::Write(::grpc::ServerContext* context, const ::kvstore::ABDWriteRequest* request, ::kvstore::ABDWriteResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* BlockingService_method_names[] = {
  "/kvstore.BlockingService/AcquireLock",
  "/kvstore.BlockingService/Read",
  "/kvstore.BlockingService/Write",
  "/kvstore.BlockingService/ReleaseLock",
};

std::unique_ptr< BlockingService::Stub> BlockingService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< BlockingService::Stub> stub(new BlockingService::Stub(channel, options));
  return stub;
}

BlockingService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_AcquireLock_(BlockingService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Read_(BlockingService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Write_(BlockingService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReleaseLock_(BlockingService_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status BlockingService::Stub::AcquireLock(::grpc::ClientContext* context, const ::kvstore::BlockingLockRequest& request, ::kvstore::BlockingLockResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::kvstore::BlockingLockRequest, ::kvstore::BlockingLockResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AcquireLock_, context, request, response);
}

void BlockingService::Stub::async::AcquireLock(::grpc::ClientContext* context, const ::kvstore::BlockingLockRequest* request, ::kvstore::BlockingLockResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::kvstore::BlockingLockRequest, ::kvstore::BlockingLockResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AcquireLock_, context, request, response, std::move(f));
}

void BlockingService::Stub::async::AcquireLock(::grpc::ClientContext* context, const ::kvstore::BlockingLockRequest* request, ::kvstore::BlockingLockResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AcquireLock_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingLockResponse>* BlockingService::Stub::PrepareAsyncAcquireLockRaw(::grpc::ClientContext* context, const ::kvstore::BlockingLockRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::kvstore::BlockingLockResponse, ::kvstore::BlockingLockRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AcquireLock_, context, request);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingLockResponse>* BlockingService::Stub::AsyncAcquireLockRaw(::grpc::ClientContext* context, const ::kvstore::BlockingLockRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAcquireLockRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status BlockingService::Stub::Read(::grpc::ClientContext* context, const ::kvstore::BlockingReadRequest& request, ::kvstore::BlockingReadResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::kvstore::BlockingReadRequest, ::kvstore::BlockingReadResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Read_, context, request, response);
}

void BlockingService::Stub::async::Read(::grpc::ClientContext* context, const ::kvstore::BlockingReadRequest* request, ::kvstore::BlockingReadResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::kvstore::BlockingReadRequest, ::kvstore::BlockingReadResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, std::move(f));
}

void BlockingService::Stub::async::Read(::grpc::ClientContext* context, const ::kvstore::BlockingReadRequest* request, ::kvstore::BlockingReadResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingReadResponse>* BlockingService::Stub::PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::kvstore::BlockingReadRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::kvstore::BlockingReadResponse, ::kvstore::BlockingReadRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Read_, context, request);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingReadResponse>* BlockingService::Stub::AsyncReadRaw(::grpc::ClientContext* context, const ::kvstore::BlockingReadRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncReadRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status BlockingService::Stub::Write(::grpc::ClientContext* context, const ::kvstore::BlockingWriteRequest& request, ::kvstore::BlockingWriteResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::kvstore::BlockingWriteRequest, ::kvstore::BlockingWriteResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Write_, context, request, response);
}

void BlockingService::Stub::async::Write(::grpc::ClientContext* context, const ::kvstore::BlockingWriteRequest* request, ::kvstore::BlockingWriteResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::kvstore::BlockingWriteRequest, ::kvstore::BlockingWriteResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Write_, context, request, response, std::move(f));
}

void BlockingService::Stub::async::Write(::grpc::ClientContext* context, const ::kvstore::BlockingWriteRequest* request, ::kvstore::BlockingWriteResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Write_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingWriteResponse>* BlockingService::Stub::PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::kvstore::BlockingWriteRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::kvstore::BlockingWriteResponse, ::kvstore::BlockingWriteRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Write_, context, request);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingWriteResponse>* BlockingService::Stub::AsyncWriteRaw(::grpc::ClientContext* context, const ::kvstore::BlockingWriteRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncWriteRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status BlockingService::Stub::ReleaseLock(::grpc::ClientContext* context, const ::kvstore::BlockingUnlockRequest& request, ::kvstore::BlockingUnlockResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::kvstore::BlockingUnlockRequest, ::kvstore::BlockingUnlockResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ReleaseLock_, context, request, response);
}

void BlockingService::Stub::async::ReleaseLock(::grpc::ClientContext* context, const ::kvstore::BlockingUnlockRequest* request, ::kvstore::BlockingUnlockResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::kvstore::BlockingUnlockRequest, ::kvstore::BlockingUnlockResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReleaseLock_, context, request, response, std::move(f));
}

void BlockingService::Stub::async::ReleaseLock(::grpc::ClientContext* context, const ::kvstore::BlockingUnlockRequest* request, ::kvstore::BlockingUnlockResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReleaseLock_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingUnlockResponse>* BlockingService::Stub::PrepareAsyncReleaseLockRaw(::grpc::ClientContext* context, const ::kvstore::BlockingUnlockRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::kvstore::BlockingUnlockResponse, ::kvstore::BlockingUnlockRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ReleaseLock_, context, request);
}

::grpc::ClientAsyncResponseReader< ::kvstore::BlockingUnlockResponse>* BlockingService::Stub::AsyncReleaseLockRaw(::grpc::ClientContext* context, const ::kvstore::BlockingUnlockRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncReleaseLockRaw(context, request, cq);
  result->StartCall();
  return result;
}

BlockingService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      BlockingService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< BlockingService::Service, ::kvstore::BlockingLockRequest, ::kvstore::BlockingLockResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](BlockingService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::kvstore::BlockingLockRequest* req,
             ::kvstore::BlockingLockResponse* resp) {
               return service->AcquireLock(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      BlockingService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< BlockingService::Service, ::kvstore::BlockingReadRequest, ::kvstore::BlockingReadResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](BlockingService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::kvstore::BlockingReadRequest* req,
             ::kvstore::BlockingReadResponse* resp) {
               return service->Read(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      BlockingService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< BlockingService::Service, ::kvstore::BlockingWriteRequest, ::kvstore::BlockingWriteResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](BlockingService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::kvstore::BlockingWriteRequest* req,
             ::kvstore::BlockingWriteResponse* resp) {
               return service->Write(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      BlockingService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< BlockingService::Service, ::kvstore::BlockingUnlockRequest, ::kvstore::BlockingUnlockResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](BlockingService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::kvstore::BlockingUnlockRequest* req,
             ::kvstore::BlockingUnlockResponse* resp) {
               return service->ReleaseLock(ctx, req, resp);
             }, this)));
}

BlockingService::Service::~Service() {
}

::grpc::Status BlockingService::Service::AcquireLock(::grpc::ServerContext* context, const ::kvstore::BlockingLockRequest* request, ::kvstore::BlockingLockResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status BlockingService::Service::Read(::grpc::ServerContext* context, const ::kvstore::BlockingReadRequest* request, ::kvstore::BlockingReadResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status BlockingService::Service::Write(::grpc::ServerContext* context, const ::kvstore::BlockingWriteRequest* request, ::kvstore::BlockingWriteResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status BlockingService::Service::ReleaseLock(::grpc::ServerContext* context, const ::kvstore::BlockingUnlockRequest* request, ::kvstore::BlockingUnlockResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace kvstore

